= 大規模プロジェクトを破壊せずにAI Agentを導入したい！
#@# もっといいタイトルのアドバイスをいただきたいです
== はじめに

//flushright{

2026年2月
nanamin

//}

数万人のユーザーを抱え、全貌を知る者がいない大規模レガシープロジェクト。そんな「絶対に破壊できない現場」において、AI Agent初心者のエンジニアがAI Agentをどうすれば安全に活用できるかをまとめた入門書です。 流行の「完全自動化」や「Vibe Coding」ではなく、既存仕様を守りながら伴走させる「Copilot」風にAI Agentを利用する現実的な運用法を模索します。

=== 想定する読者層

本書は、こんな人に向けて書かれています。

 * AIを使用せず、自分の手でコーディングしたことがある方
 * 基本的なプログラミング知識のある方
 * エンジニアやデータサイエンティストの方
 * 大規模プロジェクトや数年続いてるプロダクトに関わっている方
 * チーム開発をしていて、背景をよく知らないコードに出くわす方

=== 本書のゴール

本書を読み終わると、このような状態になっています。

 * 「壊さない」AI活用の方法がわかっている
 * 社内知識を渡す手段としてRAGを理解している
 * ツール連携の入口としてMCPを知っている
 * AI利用に伴うリスク管理の考え方としてAI TRiSMをわかっている

==== 本書でやらないこと

 * フル自動開発（AIが勝手に本番変更する）は扱わない
 * 1つのLLMツールの使い方に最適化しない（ChatGPT/Claude/Copilot/Gemini前提）
 * MLモデルの学習・ファインチューニングは扱わない

=== 前提：利用するAIツールと情報の扱い

 * 使う可能性があるツール（ChatGPT / Claude Code / GitHub Copilot / Gemini）
 * 扱う情報（PII・社外秘・運用ログなど）の注意

@<href>{https://github.com/nogu66/bookathon-team-black}

== 用語集

=== 生成AI・Copilot・AI Agentの使い分け
//table[useOfAI][生成AI・Copilot・AI Agentの使い分け]{
名前    得意な用途
-----------------------------------------------
生成AI  文章化と候補出しが得意
Copilot  実装の伴走が得意
AI Agent  ツールを使った「手順実行」が得意（ただし危険）
//}

TODO: 図1：用語の地図と、本書の守備範囲
 * 本書で必ず扱う4つ：RAG / MCP / vibe coding / AI TRiSM
 * それ以外はコラムで扱う（必要なときだけ）
#@#  参考　https://forest.watch.impress.co.jp/docs/serial/aidev/2078521.html


== 壊さない開発：AIにやらせて良い仕事・悪い仕事
=== まず結論：壊さないためのチェックリスト

 1. 目的・制約・Doneを固定する
 2. 影響範囲を調べてから書く
 3. 既存の流儀に寄せる（統一感）
 4. テストを足してから安心する
 5. 差分は小さく、PR説明は厚く

=== AIに向くタスク / 向かないタスク

 * 向く：調査・要約・観点出し・候補の列挙
 * 向く：レビュー観点・テスト観点の生成
 * 向かない：仕様の断定 / 大規模一括リライト / 本番操作

=== 壊さないための作業フロー
人が主役になりましょう。

 * Step 1：背景と制約をAIに渡す（短く・固定）
 * Step 2：影響範囲を洗い出す（検索・依存・呼び出し元）
 * Step 3：既存実装パターンを探す（統一感の確保）
 * Step 4：テストで囲う（回帰を先に作る）
 * Step 5：差分を小さく作る（分割PR・段階導入）

=== コーディング規約に寄せる
チームで暗黙のルールも明示的に書きます。例えば、コード内のコメントは英語で書く、勝手に新しいライブラリを追加しないなどです。
コーディング規約が社内Wikiなどにまとまっている場合は、そのリンクをAIに渡すのも有効です。社内wikiを参照するために、RAGやMCPを活用する方法もあります@<hd>{mcp}。
また、大規模プロジェクトの場合は活用できる既存コードが多くあるはずです。新規実装を避け、既存コードを活用するように明示的に指示しましょう。

//list[main][コーディングルールの例][md]{
 * コード内のコメントは英語で書く
 * 新しいライブラリの追加禁止
 * 詳細なコーディング規約: https://example.com/coding-guidelines
//}

ただし、Claude CodeのCLAUDE.mdのようなデフォルトで読み込まれるファイルは長ければ長いほど、性能が良くなるわけでもありません@<fn>{Writing_a_good_CLAUDEmd}。毎回のセッションで必要な情報を簡潔に書きましょう。

//footnote[Writing_a_good_CLAUDEmd]["Writing a good CLAUDE.md" https://www.humanlayer.dev/blog/writing-a-good-claude-md ]

== vibe codingの安全運用
Vibe Codeingとは
ただし、初学者がVibe Codeingしすぎると、その分野やプロジェクトへの理解が浅くなる問題があります。

 1. レベル1：提案だけ（自分で書く）
 2. レベル2：小さい差分だけ生成（1ファイル/1関数）
 3. レベル3：生成＋レビューゲート（必須チェック項目）

===[column] vibe codingが逆効果になるサイン

 * 差分の説明ができない
 * テストが増えていない
 * 既存の流儀から外れているのに気づけない


== 社内知識を渡す：RAGの超要点

RAGとは？

=== RAGが必要になる瞬間 / 不要な瞬間
 *  必要：仕様・運用・背景が散らばっている（Confluence/Slack/Jira/Drive）
 *  不要：1〜2ページの情報で足りる（まずは貼る/要約で良い）

図2：RAGの最小構成（流れだけ覚える）
Ingest（集める）→ Index（入れる）→ Retrieve（探す）→ Generate（答える）
根拠（引用元）」を出させるのが最重要

===[column] RAGが不要なケース（先にやること）
 * まずは「固定の前提メモ」を作って毎回貼る
 * ドキュメントのリンク集を整備する（検索しやすくする）

=== データソース別：取り込みと使い方のコツ
 * Confluence：ページ階層 / 更新日 / “決定事項”の抽出
 * Google Drive：版管理 / PDF化 / 重複
 * Slack：ノイズが多い→決定ログの扱いを決める
 * Jira：受入条件・背景・関連チケットを優先する

=== “壊さない”ためのRAG運用
 * スコープを狭く始める（チーム内・プロジェクト内）
 * 更新（Refresh）と「古い情報」の扱いを決める
 * 仕様が不明なときの出力形式（断定しない）

=== ミニ演習：仕様質問を「根拠付き」で答えさせる
 * 入力テンプレ（質問 / スコープ / 根拠要件）
 * 出力テンプレ（結論 / 根拠 / 不明点 / 次アクション）


=={mcp} ツール連携：MCPで安全な手足を作る

=== MCPで何が嬉しいか（RAGだけでは足りない場面）
 * 例：Jira検索・Confluence検索・Slack検索を「ツール」として呼べる
 * “AIが勝手に操作する”のではなく、“人が許可した範囲”だけ動かす

=== MCPの基本構造（用語だけ）

Host / Client / Server で責務を分ける
ツール＝関数（名前・引数・戻り値）として公開する


=== Kotlinで作る最小ツール案（擬似コードでOK）
 * tool: search_confluence(query)
 * tool: search_jira(query)
 * tool: search_slack(query)

=== エージェントに組み込むときの運用ルール
 * 人の承認ポイント（レビューゲート）を決める
 * 失敗時の挙動（分からないと言わせる / 次の質問を出す）

===[column] MCPが不要なケース
 * ツール連携をしない（IDE内の補助だけで完結）
 * まずはRAG（検索）だけで足りている


