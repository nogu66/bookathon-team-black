= 第2回Bookathonで会いましょう — AI×仮説駆動学習のススメ

== プロローグ: 基礎を疎かにしている若手エンジニアの嘆き

私は基礎学習が苦手です。応用の方がワクワクするので、つい基礎を飛ばしてしまいます。

正直に告白すると、上司に薦められた技術書は流し読み、業務で使う言語やフレームワークも「なんとなく動けばOK」という状態です。そのため、エンジニアとして新卒入社して1年経ちますが、コーディングや設計の基礎がなってないと感じています。

AIと一緒にコーディングする今、この「基礎力不足」が痛感されます。AIの提案を正しく評価できず、レビューに時間がかかります。実装後のテストで初めて問題に気づき、手戻りが発生します。結果、先輩たちと比べて開発速度が遅いのです。

同じ悩みを抱える若手エンジニアの方へ。この後、私が実践して効果があった取り組みを紹介します。少しでも参考になれば幸いです。

//pagebreak

== 第1章: Bookathonってもしして最強の学習法では？

=== 1.1 イベント駆動学習という仮説

応募する前に、私は一つの仮説を立てた。

@<b>{自分の特性的に、イベント駆動学習があっているのではないか？で、Bookathonはそれをやる最適な機会なのではないか？}

Bookathon@<fn>{bookathon}というイベントなら、強制的にインプットとアウトプットをイベントの中で行うことで、楽しく超速レベルアップができるのではないでしょうか。しかも、すごいエンジニアのメンターさんもいっぱいいるので、学ぶべき技術のアドバイスももらえます。

//footnote[bookathon][技術書を書きたい人が集まり、3日間で原稿を完成させる短期集中執筆ハッカソンイベント。技巧社や翔泳社など大手出版社の編集者や著者がメンターとして参加する。]

=== 1.2 wakameさんからの超重要アドバイス

イベント初日、メンターのwakameさんから、私の仮説を大きく変えるアドバイスをいただいた。

==== ① 現実的に2日間で何をどこまでやるか

 * @<b>{5つではなく、今回の2日間では2つがいい}
 ** 量を追いすぎると浅くなるため
 * @<b>{知らない技術ではなく、知っている技術でやった方がいい}
 ** 知らない技術 × 知らないテーマだと、確かに何もわからんで終わるな
 * @<b>{テーマ選びに関しても、3割くらい知ってるテーマだと良い}
 ** 仮説を持てないため

==== ② 仮説を持って、手を動かすと良い

 * 「このテーマやります！この技術で手動かします！」ではない
 * 例えば「失敗をいつ発見するか」というテーマでやる時に、AIが上げてきた技術を鵜呑みにして手を動かし始めるのではなく、@<b>{自分で問いに対して仮説を立てて、それに対して、手を動かして検証するという流れが良い}
 * 現状、できる先輩たちは仮説を立てて、それがあってる確率が高い
 * @<b>{そもそも仮説を立てることで、スタートラインに立つ}

==== ③ 失敗したこと、成功したことも含めてログを残す

 * 仮説が外れた → 失敗
 * 仮説があってた → 成功
 * 理由：@<b>{あとで本を読んだときに、失敗した時のログが残っていると、本の知識と繋がりやすいし、モチベーションにもなる}

=== 1.3 仮説を持って、手を動かすことにした

wakameさんのアドバイスを受けて、私の方針が固まりました。今回は、最低1つの仮説を手を動かして検証することにします。余裕があったら2つ挑戦します。使う技術はTypeScriptに絞ることにしました。

=== 1.4 自分ルール

さらに、自分なりのルールを設定しました。

==== ① 仮説を立てる際は、最初からAIに聞かない

まずは自分で考えてみて、煮詰まったらAIに聞くようにします。最初からAIに聞いてしまうと、問いを立てる力や、仮説を立てる力が付かないと思うからです。

==== ② 執筆時、ありのままを書くことを恥ずかしがらない

「こんな初歩的なことも知らないことがバレるのは恥ずかしい...」と自分を偽らないようにします。恥ずかしい気持ちをあえて感じることで、これからの勉強への原動力にするためです。

//pagebreak

== 第2章: 「失敗をいつ発見するか」というテーマに決めた

=== 2.1 なぜこのテーマなのか

技術を横断する軸の案をAIに出してもらった中で、「失敗をいつ発見するか」というテーマを選びました。

理由は3つあります。1つ目は、自分が少し知ってるテーマだからです。2つ目は、プロダクトを提供する一エンジニアとして、失敗は防止するべき分野だと思うからです。3つ目は、仕事で、これからAIエージェントのテスト設計などを行うため、その足掛かりとしたいためです。

=== 2.2 開発速度が遅いだけで、失敗はしていないのでは？

テーマを決めた時点で、自分の現状を振り返りました。

==== 今の私の「失敗」に対する認識

新規プロダクトを開発しており、まだ私起因のエラーやインシデントは起きていません。開発速度が遅いだけで、失敗はしていないのでは？？

==== → AIとの壁打ちの結果：そんなことはない

以下の2つの理由によって既に失敗していることがわかりました。

===== ① 開発速度が遅い理由の一つに、実装後に動作確認してみたら意図した動作と違い手戻りが起きたということが起こっている

フロント側の状態管理が複雑になってきた影響で、ローカルで動作確認をしたら、意図した実装になっていませんでした。型エラーやビルドエラー、実行時エラーはなかったので、動作確認をして私が確認するまで、わからなかったということになります。

===== ② 将来の外部失敗 or 開発速度が落ちる失敗の種を作っている可能性が高い

きっと、コードの複雑性を増やしてしまっています。また、良いテストも書けていない気がするため、偽陽性となる可能性もあります。

=== 2.3 「失敗」を3段階で定義してみた

失敗レベル：

 1. 将来自分か、他人に2, 3を起こさせてしまうコードを生成すること
 2. 開発中の手戻りにより開発速度が落ちること
 3. 運用中のエラーによってインシデントが起きること

=== 2.4 仮説を立てるために、まず考えてみることにした

失敗の3段階を定義したところで、次は「仮説を立てる」フェーズです。

でも、ここで手が止まりました。@<b>{AIのレビューで発見できる失敗って何だろう？}

そもそも、AIのレビューで発見できるものを仮説にしても、あまり意味がない気がします。AIに投げれば済む話だし...。じゃあ、AIのレビューで発見できないものって何だ？

考えてみましたが、うまく言語化できません。

==== → まずは、AIのレビューで発見できるものから考えてみよう

方向性を変えることにしました。まずは、AIのレビューで発見できるものを整理して、そこから深掘りしていけば、何か見えてくるかもしれません。

最初に思いついたのが「型エラー」でした。

でも、ここでまた疑問が湧きます。@<b>{型エラーって、AI使わなくても型チェックで発見できるよね？VSCodeでもエラー出るし。じゃあ、それをわざわざ深掘りする理由って何だろう？}

この疑問こそが、仮説を立てる入り口になりました。

//pagebreak

== 第3章: 1つ目の問い「型定義に穴があると、どの時点でエラーが起きるのか？」

=== 3.1 今回は型エラーに絞ってみることにした

前章で浮かんだ疑問「型チェックがあるのに、なぜ型を深掘りするのか？」から考え始めました。

考え始めると、疑問がどんどん出てきます。

 * 型エラーって、正確には何を指すんだっけ？
 * 型エラーがないと、どの時点でどういうエラーが起きるんだっけ？
 * lint checkで発見できるんじゃないか？
 * VSCodeでエラー表示されるよね？
 * でも、テストファイルの型エラーをAIがいつまでも治せなかった覚えがある...なぜ？

@<b>{考え始めると、どんどん疑問が出てくる、案外知らないこと多い！！！！}

当たり前に使っている型と型エラーに関して今回は深ぼることにしました。

いつも、空気のように感じていた型というものはなんなのか？それが分からなくても、別に型チェックによって防止してくれるのに、それを深ぼる理由はなんだ？？

=== 3.2 衝撃の事実：型エラーが出なくても不具合は起きる

煮詰まったので、AIに聞いてみました。

==== → AIに聞いた結果わかったこと

@<b>{型定義に穴があると、後々エラーとしても出ない不具合が起きる}

これは衝撃でした。正直、今まで型を蔑ろにしていました。@<b>{型エラーがでなければOK、anyはダメくらいの気持ちでした。}

これまでAIが定義した型にちゃんと目を通してこなかったのです。そして今も、どういう観点で型をチェックすればいいか分かりません。

@<b>{今まで書いてきたコードが不安になってきました。}

=== 3.3 問いの設定と実験シチュエーション

==== 問い：型定義に穴があると、どの時点でエラーが起きるのか？

==== 実験のためのシチュエーション定義：ユーザー登録機能

==== 仮説を出すまでの思考

この機能において、どんな型が考えられるでしょうか？（多分AI使わず自分で書けば普通にミスる気がします）

ユーザー型：

//emlist[ユーザー型][typescript]{
User = {
  id: number,
  name: string,
  email: string,
  password: string
}
//}

バックエンドに登録内容をポストする関数の型定義：

//emlist[registerUser関数][typescript]{
function registerUser(user: User): 成功したかしてないかの返り値の型 {

}
//}

@<b>{これでミスるかどうかも分かりません。}

成功したかしてないかの返り値の型というのは、ライブラリでpostした結果のオブジェクトをそのまま入れるものにしようと思っています。

一旦、成功したかしてないかの返り値の型が分からないので、AIに聞いてみることにしました。

==== AIに聞いた結果

Result型を用意した方がいいとのことでした。じゃないと、@<b>{ライブラリを変えた時に面倒}になります。特定のライブラリに依存した型になってしまい、呼び出し元がライブラリの詳細を知る必要が出てきます。また、@<b>{返り値の中から必要な情報を取り出すのが煩雑になる}という問題もあります。

=== 3.4 仮説と検証

@<b>{【ここに仮説を記述予定】}

@<b>{【ここに実験コードと結果を記述予定】}

@<b>{【ここに考察を記述予定】}

=== 3.5 1つ目の問いから学んだこと

@<b>{【ここに学びを記述予定】}

//pagebreak

== 第4章: 2つ目の問い「【2つ目の問いタイトル】」

//note[第4章について]{
第4章は、1つ目の検証が終わった後に執筆予定です。間に合わなければ丸ごとカット可能です。
//}

=== 4.1 1つ目の検証から生まれた新たな疑問

@<b>{【1つ目の検証結果を踏まえた問題意識】}

=== 4.2 問いの設定と実験シチュエーション

@<b>{【2つ目の実験シチュエーション】}

=== 4.3 仮説と検証

@<b>{【仮説】}

@<b>{【実験コードと結果】}

@<b>{【考察】}

=== 4.4 2つ目の問いから学んだこと

@<b>{【学び】}

//pagebreak

== 第5章: Bookathonハックで得た学び

=== 5.1 仮説駆動で学ぶことの効果

==== 問いを立てることでスタートラインに立てた

wakameさんの言葉通り、「仮説を立てることでスタートラインに立つ」という経験をしました。

==== 失敗した時のログが残っていると本の知識と繋がりやすい

自分で仮説を立てて、失敗して、その過程を記録しておきます。

これから技術書を読むときに、「あ、これBookathonで失敗したやつだ！」と繋がる瞬間が楽しみです。

=== 5.2 イベント駆動学習は自分に合っていたのか

==== 2日間で何が変わったか

@<b>{【ここに2日間の変化を記述予定】}

==== TypeScriptに絞って深掘りした結果

@<b>{【ここに深掘りの結果を記述予定】}

=== 5.3 技術が未熟な新卒エンジニアのための学び方

==== 完璧な知識がなくても大丈夫

@<b>{【ここに学びを記述予定】}

==== 恥ずかしがらずにありのままを書く意味

「型エラーがでなければOK」くらいの認識だった自分、「これでミスるかどうかも分からん」と書いた自分。

これらを隠さず書くことで、これから勉強するモチベーションになります。

==== 次はどんな問いを立てるか

@<b>{【ここに次の問いを記述予定】}

//pagebreak

== エピローグ: 書きたいテーマがなくて応募が怖いあなたへ

=== 私も最初は不安でした

「書きたいテーマがない」「技術力が足りない」「他の参加者はすごい人ばかりなのでは」

私も同じ不安を抱えていました。

でも、Bookathonは、@<b>{完璧な知識がなくても、テーマが明確でなくても、参加できるイベント}でした。

=== Bookathonをフルに使った超加速学習のススメ

メンターさんにアドバイスをもらい、仮説を立てて、手を動かし、失敗も成功もログに残し、ありのままを書く。これだけで、2日間で驚くほど成長できます。

=== 第2回で会いましょう

この記事を読んで、少しでも「応募してみようかな」と思ってくれたら嬉しいです。

第2回Bookathonで、あなたに会えることを楽しみにしています。

//pagebreak

== 対象読者

 * 私のような若手エンジニア
 * 第2回Bookathonに興味があるけど、書きたいテーマがなくて応募が怖い人
