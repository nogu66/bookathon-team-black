= 第2回Bookathonで会いましょう — AI×仮説駆動学習のススメ

== プロローグ: 基礎を疎かにしている若手エンジニアの嘆き

私は基礎学習が苦手です。応用の方がワクワクするので、つい基礎を飛ばしてしまいます。正直に告白すると、上司に薦められた技術書は流し読み、業務で使う言語やフレームワークも「なんとなく動けばOK」という状態です。そのため、エンジニアとして新卒入社して1年経ちますが、コーディングや設計の基礎がなってないと感じています。AIと一緒にコーディングする今、この「基礎力不足」が痛感されます。AIの提案を正しく評価できず、レビューに時間がかかります。実装後のテストで初めて問題に気づき、手戻りが発生します。結果、先輩たちと比べて開発速度が遅いのです。同じ悩みを抱える若手エンジニアの方へ。この後、私が実践して効果があった取り組みを紹介します。少しでも参考になれば幸いです。

//pagebreak

== Bookathonってもしして最強の学習法では？

=== イベント駆動学習という仮説

応募する前に、私は一つの仮説を立てた。@<b>{自分の特性的に、イベント駆動学習があっているのではないか？で、Bookathonはそれをやる最適な機会なのではないか？}Bookathon@<fn>{bookathon}というイベントなら、強制的にインプットとアウトプットをイベントの中で行うことで、楽しく超速レベルアップができるのではないでしょうか。しかも、すごいエンジニアのメンターさんもいっぱいいるので、学ぶべき技術のアドバイスももらえます。

//footnote[bookathon][技術書を書きたい人が集まり、3日間で原稿を完成させる短期集中執筆ハッカソンイベント。技巧社や翔泳社など大手出版社の編集者や著者がメンターとして参加する。]

=== wakameさんからの超重要アドバイス

イベント初日、メンターのwakameさんから、私の仮説を大きく変えるアドバイスをいただいた。

==== ① 現実的に2日間で何をどこまでやるか

 * @<b>{5つではなく、今回の2日間では2つがいい}
 ** 量を追いすぎると浅くなるため
 * @<b>{知らない技術ではなく、知っている技術でやった方がいい}
 ** 知らない技術 × 知らないテーマだと、確かに何もわからんで終わるな
 * @<b>{テーマ選びに関しても、3割くらい知ってるテーマだと良い}
 ** 仮説を持てないため

==== ② 仮説を持って、手を動かすと良い

 * 「このテーマやります！この技術で手動かします！」ではない
 * 例えば「失敗をいつ発見するか」というテーマでやる時に、AIが上げてきた技術を鵜呑みにして手を動かし始めるのではなく、@<b>{自分で問いに対して仮説を立てて、それに対して、手を動かして検証するという流れが良い}
 * 現状、できる先輩たちは仮説を立てて、それがあってる確率が高い
 * @<b>{そもそも仮説を立てることで、スタートラインに立つ}

==== ③ 失敗したこと、成功したことも含めてログを残す

 * 仮説が外れた → 失敗
 * 仮説があってた → 成功
 * 理由：@<b>{あとで本を読んだときに、失敗した時のログが残っていると、本の知識と繋がりやすいし、モチベーションにもなる}

=== 仮説を持って、手を動かすことにした

wakameさんのアドバイスを受けて、私の方針が固まりました。今回は、最低1つの仮説を手を動かして検証することにします。余裕があったら2つ挑戦します。使う技術はTypeScriptに絞ることにしました。

=== 自分ルール

さらに、自分なりのルールを設定しました。

==== ① 仮説を立てる際は、最初からAIに聞かない

まずは自分で考えてみて、煮詰まったらAIに聞くようにします。最初からAIに聞いてしまうと、問いを立てる力や、仮説を立てる力が付かないと思うからです。

==== ② 執筆時、ありのままを書くことを恥ずかしがらない

「こんな初歩的なことも知らないことがバレるのは恥ずかしい...」と自分を偽らないようにします。恥ずかしい気持ちをあえて感じることで、これからの勉強への原動力にするためです。

//pagebreak

== 「失敗をいつ発見するか」というテーマに決めた

=== なぜこのテーマなのか

技術を横断する軸の案をAIに出してもらった中で、「失敗をいつ発見するか」というテーマを選びました。理由は3つあります。1つ目は、自分が少し知ってるテーマだからです。2つ目は、プロダクトを提供する一エンジニアとして、失敗は防止するべき分野だと思うからです。3つ目は、仕事で、これからAIエージェントのテスト設計などを行うため、その足掛かりとしたいためです。

=== 開発速度が遅いだけで、失敗はしていないのでは？

新規プロダクトを開発しており、まだ私起因のエラーやインシデントは起きていません。開発速度が遅いだけで、失敗はしていないのでは？？しかしAIとの壁打ちの結果、そんなことはないとわかりました。以下の2つの理由によって既に失敗していることが判明したのです。1つ目は、@<b>{実装後に動作確認してみたら意図した動作と違い手戻りが起きている}ということです。フロント側の状態管理が複雑になってきた影響で、ローカルで動作確認をしたら、意図した実装になっていませんでした。型エラーやビルドエラー、実行時エラーはなかったので、動作確認をして私が確認するまで、わからなかったということになります。2つ目は、@<b>{将来の外部失敗 or 開発速度が落ちる失敗の種を作っている可能性が高い}ということです。きっと、コードの複雑性を増やしてしまっています。また、良いテストも書けていない気がするため、偽陽性となる可能性もあります。

=== 「失敗」を3段階で定義してみた

失敗レベル：

 1. 将来自分か、他人に2, 3を起こさせてしまうコードを生成すること
 2. 開発中の手戻りにより開発速度が落ちること
 3. 運用中のエラーによってインシデントが起きること

=== 仮説を立てるために、まず考えてみることにした

失敗の3段階を定義したところで、次は「仮説を立てる」フェーズです。でも、ここで手が止まりました。@<b>{AIのレビューで発見できる失敗って何だろう？}そもそも、AIのレビューで発見できるものを仮説にしても、あまり意味がない気がします。AIに投げれば済む話だし...。じゃあ、AIのレビューで発見できないものって何だ？考えてみましたが、うまく言語化できません。方向性を変えることにしました。まずは、AIのレビューで発見できるものを整理して、そこから深掘りしていけば、何か見えてくるかもしれません。最初に思いついたのが「型エラー」でした。でも、ここでまた疑問が湧きます。@<b>{型エラーって、AI使わなくても型チェックで発見できるよね？VSCodeでもエラー出るし。じゃあ、それをわざわざ深掘りする理由って何だろう？}この疑問こそが、仮説を立てる入り口になりました。

//pagebreak

== 1つ目の問い「型定義に穴があると、どの時点でエラーが起きるのか？」

=== 今回は型エラーに絞ってみることにした

前章で浮かんだ疑問「型チェックがあるのに、なぜ型を深掘りするのか？」から考え始めました。考え始めると、疑問がどんどん出てきます。

 * 型エラーって、正確には何を指すんだっけ？
 * 型エラーがないと、どの時点でどういうエラーが起きるんだっけ？
 * lint checkで発見できるんじゃないか？
 * VSCodeでエラー表示されるよね？
 * でも、テストファイルの型エラーをAIがいつまでも治せなかった覚えがある...なぜ？

@<b>{考え始めると、どんどん疑問が出てくる、案外知らないこと多い！！！！}当たり前に使っている型と型エラーに関して今回は深ぼることにしました。いつも、空気のように感じていた型というものはなんなのか？それが分からなくても、別に型チェックによって防止してくれるのに、それを深ぼる理由はなんだ？？

=== 衝撃の事実：型エラーが出なくても不具合は起きる

煮詰まったので、AIに聞いてみました。AIに聞いた結果わかったことは、@<b>{型定義に穴があると、後々エラーとしても出ない不具合が起きる}ということです。これは衝撃でした。正直、今まで型を蔑ろにしていました。@<b>{型エラーがでなければOK、anyはダメくらいの気持ちでした。}これまでAIが定義した型にちゃんと目を通してこなかったのです。そして今も、どういう観点で型をチェックすればいいか分かりません。@<b>{今まで書いてきたコードが不安になってきました。}

=== 問いの設定と実験シチュエーション

問いは「@<b>{型定義に穴があると、どの時点でエラーが起きるのか？}」としました。実験のシチュエーションは「ユーザー登録機能」に設定します。バックエンドにデータをPOSTするというシンプルな機能なので、型定義の問題だけに集中できると考えたからです。では、この機能において、どんな型が考えられるでしょうか？（多分AI使わず自分で書けば普通にミスる気がします）まず、自分なりにユーザー型を考えてみました：

//emlist[ユーザー型（自分で考えたもの）][typescript]{
User = {
  id: number,
  name: string,
  email: string,
  password: string
}
//}

次に、バックエンドに登録内容をポストする関数の型定義も考えてみました。ただし、返り値の型をどうすればいいか分からなかったので、仮置きで日本語を書いています：

//emlist[registerUser関数（返り値の型が分からない）][typescript]{
function registerUser(user: User): 成功したかしてないかの返り値の型 {

}
//}

@<b>{これでミスるかどうかも分かりません。}成功したかしてないかの返り値の型というのは、ライブラリでpostした結果のオブジェクトをそのまま入れるものにしようと思っています。一旦、成功したかしてないかの返り値の型が分からないので、AIに聞いてみることにしました。AIに聞いた結果、Result型を用意した方がいいとのことでした。じゃないと、@<b>{ライブラリを変えた時に面倒}になるそうです。特定のライブラリに依存した型になってしまい、呼び出し元がライブラリの詳細を知る必要が出てくるとのことでした。

=== 仮説の設定

AIの回答を聞いて、「ライブラリを変えた時に面倒」とは言うものの、@<b>{本当にそんなに面倒なのか？}という疑問が湧きました。そこで、以下の仮説を立てました。

==== 仮説：ライブラリに依存した型定義にすると、他のライブラリに変えた時にめちゃめちゃ面倒くさくなる

これまでよく聞く話ですが、正直実感が湧きませんでした。@<b>{どう面倒臭いかあんま見えてないので、自分の手で検証してみることにしました。}

==== 仮説検証の手順

 1. ユーザー型と、Axiosに依存した型定義をした、post関数を用意する（バックエンドと実際に通信はしない）
 2. 動くことを確認する
 3. 他のライブラリに変えるとなったら、どのくらい大変？

@<b>{今の予想：ゆうてこのくらいのシンプルな実験だったら、全然大変じゃないんじゃね？}もし大変じゃなかったとしたら、今後どんな機能が追加されたら、大変になる？と考えます。

=== 実験1: Axiosに依存した型定義を作ってみた

==== ステップ1・2：Axiosで実装して動作確認

まず、ユーザー型を用意します。

//list[types][types.ts][typescript]{
export type User = {
  id: number;
  name: string;
  email: string;
  password: string;
};
//}

次に、このユーザー型を使って、Axiosに依存した型定義の関数を作ります。ここが今回の実験のポイントです。

//list[user-service-axios][user-service-axios.ts][typescript]{
import axios, { AxiosResponse } from 'axios';
import { User } from './types.js';

export async function registerUser(user: User): Promise<AxiosResponse> {
  // 実際にはバックエンドに送信しないが、型定義の検証のためにコメントで残す
  // return await axios.post('https://api.example.com/users', user);

  return {
    data: { success: true, userId: user.id },
    status: 200,
    statusText: 'OK',
    headers: {},
    config: {
      headers: {} as any
    }
  } as AxiosResponse;
}
//}

//note[なぜモックレスポンスを使うのか]{
実際にAPI通信を行わない理由は2つあります。1つ目は、@<code>{example.com/users}はPOSTを受け付けていないためです。2つ目は、今回の検証は「型定義の依存性」に焦点を当てているため、実際の通信は本質的ではありません。むしろ、通信エラーやネットワークの問題など、本来の検証目的とは無関係な問題に時間を取られる可能性があります。

なお、実際にAPI通信を試したい場合は、@<href>{https://jsonplaceholder.typicode.com/users}のような公開テストAPIが利用できます。
//}

@<b>{返り値の型がPromise<AxiosResponse>になっています。}これが特定のライブラリに依存した型定義です。動作確認のコードは以下の通りです。
//list[main][main.ts][typescript]{
import { registerUser } from './user-service-axios.js';
import { User } from './types.js';

async function experiment1() {
  const testUser: User = {
    id: 1,
    name: '山田太郎',
    email: 'yamada@example.com',
    password: 'password123'
  };

  const response = await registerUser(testUser);

  console.log('ステータスコード:', response.status);
  console.log('ステータステキスト:', response.statusText);
  console.log('レスポンスデータ:', response.data);

  if (response.status === 200) {
    console.log('✅ ユーザー登録成功!');
  }
}

experiment1();
//}

実行してみると、以下のような出力が得られました：

//cmd{
ステータスコード: 200
ステータステキスト: OK
レスポンスデータ: { success: true, userId: 1 }
✅ ユーザー登録成功!
//}

@<b>{ちゃんと動きました！}しかし、ここで問題に気づきます。呼び出し元のコードを見ると、@<code>{response.status}、@<code>{response.statusText}、@<code>{response.data}という@<b>{Axiosの型に依存したプロパティに直接アクセスしています。}

==== ステップ3：fetchに変更してみたら...

実際にライブラリを変更するとどのくらい大変なのか、試してみることにしました。AxiosからfetchのResponse型に変更します。

//list[user-service-fetch][user-service.ts][typescript]{
import { User } from './types.js';

export async function registerUser(user: User): Promise<Response> {
  // 実際にはバックエンドに送信しないが、型定義の検証のためにコメントで残す
  // return await fetch('https://api.example.com/users', {
  //   method: 'POST',
  //   headers: { 'Content-Type': 'application/json' },
  //   body: JSON.stringify(user),
  // });

  return new Response(
    JSON.stringify({ success: true, userId: user.id }),
    {
      status: 200,
      statusText: 'OK',
      headers: { 'Content-Type': 'application/json' }
    }
  );
}
//}

すると、呼び出し元のコードも変更が必要になります。

//list[main-fetch][main.ts（fetch版）][typescript]{
import { registerUser } from './user-service.js';
import { User } from './types.js';

async function experiment1() {
  const testUser: User = {
    id: 1,
    name: '山田太郎',
    email: 'yamada@example.com',
    password: 'password123'
  };

  const response = await registerUser(testUser);

  console.log('ステータスコード:', response.status);
  console.log('ステータステキスト:', response.statusText);

  // ⚠️ Axiosと違い、dataプロパティは存在しない
  // レスポンスボディを明示的にパースする必要がある
  const data = await response.json();
  console.log('レスポンスデータ:', data);

  if (response.status === 200) {
    console.log('✅ ユーザー登録成功!');
  }
}

experiment1();
//}

@<b>{呼び出し元のコードを変更する必要が出てきました。}Axiosでは@<code>{response.data}で直接JSONオブジェクトにアクセスできましたが、fetchでは@<code>{await response.json()}で明示的にパースが必要です。これは良くありません。なぜなら、@<b>{呼び出し元がライブラリのレスポンスのデータ構造を知っておかなければならないから}です。また、ライブラリを変更するだけでなく、@<b>{ライブラリのアップデートやバージョン変更などで構造が変わったら、呼び出し元のコードも変更しなければならない}というリスクもあります。

=== ここまでの実験で感じたこと

型エラーが出ないからといって、良い型定義とは限りません。@<b>{返り値の型が特定のライブラリに依存していると、将来の変更が困難になります。}実際にコードを書いて動かすことで、その意味が腹落ちしました。@<b>{知識として知っていることと、実感として理解することは全く違います。}でも正直「言うて一行じゃね？」とも思いました。@<code>{response.data}を@<code>{await response.json()}に変えるだけでしょ？と。確かに呼び出し箇所が多ければだるいですが、@<b>{全部置換すればいいんじゃないか}とも思いました。本当に単純な置換で済まないケースはあるのでしょうか？

=== 「置き換えればいいじゃん」が通用しないケースを試してみた

「全部置換すればいいんじゃないか？」という疑問を持ったので、実際に検証してみることにしました。AIに「コード追加は最小限で、なおかつ『置き換えればいいじゃん』が通用しないことを私に分からせるケースを作ってください」と指示して、コードを追加してもらいました。以下のコードは、@<b>{Axiosの@<code>{response.data}を@<code>{await response.json()}に単純置換した結果、エラーが起きることを示すための実験コード}です。意図的にエラーが出るように書いています。

//list[main-patterns][main.ts（fetchに変更後）][typescript]{
import { registerUser } from './user-service.js';
import { User } from './types.js';

async function main() {
  const testUser: User = {
    id: 1,
    name: '山田太郎',
    email: 'yamada@example.com',
    password: 'password123'
  };

  const response = await registerUser(testUser);

  // パターン1: 単純なdata参照
  console.log('1. レスポンスデータ:', await response.json());

  // パターン2: dataの中のプロパティを直接参照
  console.log('2. ユーザーID:', await response.json().userId);

  // パターン3: 条件分岐でdataを使用
  if (await response.json().success) {
    console.log('3. 成功フラグ確認: OK');
  }

  // パターン4: dataを変数に格納して使用
  const result = await response.json();
  console.log('4. 変数経由でアクセス:', result.userId);

  // パターン5: 分割代入
  const { success, userId } = await response.json();
  console.log('5. 分割代入:', success, userId);
}

main();
//}

@<b>{実際にファイルを開いたら、型エラーがたくさん出ていました。これは確かにヤバそうです。}エラーメッセージはこんな感じでした：

//emlist[][]{
プロパティ 'userId' は型 'Promise<unknown>' に存在しません。
プロパティ 'success' は型 'Promise<unknown>' に存在しません。
'result' は 'unknown' 型です。
プロパティ 'success' は型 'unknown' に存在しません。
プロパティ 'userId' は型 'unknown' に存在しません。
//}

なぜエラーが出ているか分からなかったので、またAIに聞いてみました。すると、@<b>{Axiosとfetchでレスポンスのデータ型が全然違う}ことが分かりました。

 * @<b>{Axiosのresponse.data}: JSONにパースされたオブジェクト
 * @<b>{fetchのresponse.json()}: 生データをJSONにパースするメソッド

さらに、@<b>{fetchはストリームという仕組みを使っているため、一度生データからJSONに変換したら、生データは消えてしまう}そうです。メモリを節約するため、生データがめっちゃ大きかった時のために、そういう設計になっているとのこと。@<b>{全然そんなこと知らなかったです！}私、「JSONにパースするだけじゃん。@<code>{.json()}挟むだけじゃん」って思ってたら、@<b>{まさかの中身のデータ型が全然違ってた}ということを知りませんでした。だから、上記のコードでは@<code>{response.json()}を何度も呼んでいますが、2回目以降はエラーになります。@<b>{一度パースしたら、もう生データは残っていないから}です。（fetch面倒くさいですね..！とはいえ、データ量が多い時は助かるような気がするので、使い分けなのだなぁと思いました。）つまり、@<code>{response.data}を@<code>{await response.json()}に単純置換すると、以下の問題が起きます：

 1. @<b>{何度もアクセスしている箇所}で、2回目以降がエラーになる
 2. @<b>{変数に入れるタイミング}を考え直す必要がある
 3. @<b>{各パターンごとに個別対応}が必要

そんなことを呼び出し側はいちいち考えてられません。@<b>{確かにこれは絶対にライブラリに依存した型を返り値に設定するべきじゃないな}と実感しました。さらに、他のHTTPライブラリの返り値の型を調べてみました。例えば@<b>{got}というライブラリは、プロパティ名がちょくちょく違っていました：

 * Axiosでは@<code>{response.status}だが、gotでは@<code>{response.statusCode}
 * Axiosでは@<code>{response.data}だが、gotでは@<code>{response.body}

ライブラリが違えば、こんなにもプロパティ名が変わってしまいます。@<b>{ちゃんと、呼び出し側はライブラリの詳細を知らなくても使えるようにしないとだな}という理想を思いました。

=== 問いに対する答え

今回の検証で分かったことは、@<b>{型エラーとしては起きない}ということです。TypeScriptの型チェックは通ります。しかし、@<b>{変更を加えた時点で問題が顕在化}します。具体的には以下の通りです。

 * @<b>{ライブラリ変更時に、呼び出し側すべての修正が必要になる}
 ** 前節の実験で見たように、単純置換では済まない複雑な修正が必要
 * @<b>{型エラーは出ないため、実行して初めて気づくケースもある}
 ** @<code>{response.json()}を複数回呼ぶとエラーになるが、型チェックでは検出されない
 * @<b>{影響範囲が広いほど、修正コストが膨大になる}
 ** 呼び出し箇所が増えるほど、手動での確認・修正作業が増える

つまり「型定義に穴がある」とは、@<b>{型チェックをすり抜けて、将来の変更を困難にする設計上の問題を含んでいる状態}のことでした。今回の場合、@<code>{Promise<AxiosResponse>}という型定義は文法的には正しく、型チェックも通ります。しかし、ライブラリの実装の詳細に依存しているという「穴」があったのです。この穴は、型システムでは検出できません。だからこそ、@<b>{型定義を書く時点で、将来の変更を見据えた設計が必要}だと実感しました。

=== AIに聞いてみた：「これを抽象化したらどうなりますか？」

ここまで学んだ後、ふと疑問が湧きました。今回学んだ「ライブラリの型を返り値にしない」という知識は、他の場面でも使えるのでしょうか？@<b>{「これを抽象化したらどうなりますか？」とAIに聞いてみました。}AIは、より汎用的な判断基準を教えてくれました：

 1. @<b>{これは境界（外部と内部の接点）か？}
 ** 境界なら、外部の型を内部の型に変換しているか？
 2. @<b>{これは置き換え可能か？}
 ** 実装を変えたとき、この型定義も変える必要があるか？
 3. @<b>{これはテストしやすいか？}
 ** モックを書くのが面倒か？

1つでも「問題あり」なら、型定義を見直す必要があるとのことです。本質は「@<b>{実装の詳細が、インターフェースに漏れ出していないか？}」ということでした。今回の場合：

 * 実装の詳細：Axiosを使っている
 * インターフェース：registerUser関数の型定義
 * 漏れ出し：@<code>{Promise<AxiosResponse>}という返り値の型

@<b>{実装の詳細（Axios）が、インターフェース（型定義）に漏れ出していた}のが問題だったのです。AIは「依存性逆転の原則（SOLID原則のD）に違反している」とも教えてくれました。正直、これまでSOLID原則は何度も聞いたことがあったのですが、@<b>{暗記みたいで全然覚えられませんでした。}でも、今回の実験を通して、@<b>{「依存性逆転ってこういうことか！」と実感として理解}できました。理想の依存関係と、今回の問題のある依存関係を比べてみます。

//emlist[理想：抽象を介して依存する]{
┌──────────────────────┐
│   呼び出し側（上位）    │
└─────────┬────────────┘
          │ 依存
          ▼
┌──────────────────────┐
│  抽象的な型            │
│  （Result<T, E>）      │
└─────────┬────────────┘
          │ 依存
          ▼
┌──────────────────────┐
│  実装（Axios, fetch）  │
└──────────────────────┘
//}

//emlist[問題（今回のケース）：具体に直接依存している]{
┌──────────────────────┐
│   呼び出し側（上位）    │
└─────────┬────────────┘
          │ 依存
          ▼
┌──────────────────────┐
│  Promise<AxiosResponse>│ ← 具体的なライブラリの型！
│  （具体的な型）         │
└──────────────────────┘
          ↑ 逆向きの依存
┌──────────────────────┐
│  実装（Axios）         │
└──────────────────────┘
//}

@<b>{抽象が具象に依存してしまっていた}のです。「テストしやすいか？」という観点も腹落ちしました。確かに、実装の具体的な詳細を型に反映してしまっていたら、@<b>{その具体に関してうまくモックできません。}

//list[mock-comparison][モックの複雑さの違い][typescript]{
// ❌ モックが複雑（Axiosの詳細を知る必要がある）
const mockResponse: AxiosResponse = {
  data: { id: 1 },
  status: 200,
  statusText: 'OK',
  headers: {},
  config: { headers: {} as any }
};

// ✅ モックが簡単（ドメインの知識だけでOK）
const mockResult: Result<User, Error> = {
  success: true,
  data: { id: 1, name: 'test' }
};
//}

「@<code>{Promise<AxiosResponse>}はダメ」と覚えるのではなく、@<b>{「なぜダメなのか」「どう判断すればいいのか」という考え方を手に入れること}が大事だと気づきました。これなら、次に別のライブラリを使うときも、データベースを使うときも、同じ考え方で判断できます。@<b>{知識として知っていたSOLID原則が、実感として理解できたのが、今回の一番の収穫}です。

//pagebreak

== 2つ目の問い「【2つ目の問いタイトル】」

//note[第4章について]{
第4章は、1つ目の検証が終わった後に執筆予定です。間に合わなければ丸ごとカット可能です。
//}

=== 1つ目の検証から生まれた新たな疑問

@<b>{【1つ目の検証結果を踏まえた問題意識】}

=== 問いの設定と実験シチュエーション

@<b>{【2つ目の実験シチュエーション】}

=== 仮説と検証

@<b>{【仮説】}

@<b>{【実験コードと結果】}

@<b>{【考察】}

=== 2つ目の問いから学んだこと

@<b>{【学び】}

//pagebreak

== Bookathonハックで得た学び

=== 仮説駆動で学ぶことの効果

wakameさんの言葉通り、「仮説を立てることでスタートラインに立つ」という経験をしました。自分で仮説を立てて、失敗して、その過程を記録しておきます。これから技術書を読むときに、「あ、これBookathonで失敗したやつだ！」と繋がる瞬間が楽しみです。

=== イベント駆動学習は自分に合っていたのか

@<b>{【ここに2日間の変化を記述予定】}

@<b>{【ここに深掘りの結果を記述予定】}

=== 技術が未熟な新卒エンジニアのための学び方

@<b>{【ここに学びを記述予定】}

「型エラーがでなければOK」くらいの認識だった自分、「これでミスるかどうかも分からん」と書いた自分。これらを隠さず書くことで、これから勉強するモチベーションになります。

@<b>{【ここに次の問いを記述予定】}

//pagebreak

== エピローグ: 書きたいテーマがなくて応募が怖いあなたへ

「書きたいテーマがない」「技術力が足りない」「他の参加者はすごい人ばかりなのでは」私も同じ不安を抱えていました。でも、Bookathonは、@<b>{完璧な知識がなくても、テーマが明確でなくても、参加できるイベント}でした。メンターさんにアドバイスをもらい、仮説を立てて、手を動かし、失敗も成功もログに残し、ありのままを書く。これだけで、2日間で驚くほど成長できます。この記事を読んで、少しでも「応募してみようかな」と思ってくれたら嬉しいです。第2回Bookathonで、あなたに会えることを楽しみにしています。

//pagebreak

== 対象読者

 * 私のような若手エンジニア
 * 第2回Bookathonに興味があるけど、書きたいテーマがなくて応募が怖い人
