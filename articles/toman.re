= 第2回Bookathonで会いましょう — 応募が怖かった私が、AI×仮説駆動学習で変わった2日間

== プロローグ: 上司に勧められた本、読めてません

正直に言います。上司に読むように勧められた技術書、ちゃんと読めていません。

新卒エンジニアとして入社してから数ヶ月。日々の開発に追われる中で、私は自分の苦手なことに向き合っていました。そして、それは1つや2つではなく、3つもあります。

//embed[latex]{
\begin{itemize}
\item 一つの本をじっくり読む勉強
\item 一つの技術をじっくり極める
\item 継続的な勉強
\end{itemize}
//}

読書が苦手。一つのことを深く学ぶのが苦手。そして何より、継続的に勉強することが苦手。

そのため、正直上司に読もうと言われた本も、ちゃんと読めてないし、@<b>{新卒のこの時期なのにコーディングや設計の基礎がなってないと感じています。}

特に最近は、AIと一緒にコーディングすることが多くなりました。でも、AIが提案してきた設計書や実装計画書をレビューするのに時間がかかって、「あれ、これで合ってるのかな？」と不安になることが多いんです。エンジニアとしてのレベルが足りないと感じる日々でした。

でも、ある日、「Bookathon」というイベントの存在を知りました。

2日間で技術書を読んで、手を動かして、記事を書くというイベント。しかも、すごいエンジニアのメンターさんがいっぱいいて、アドバイスももらえるらしい。

もしかしたら、このイベントなら、私でも変われるかもしれない。

そんな期待を胸に、私は第1回Bookathonに応募しました。

//pagebreak

== Bookathonってもしかして最強の学習法では？

=== イベント駆動学習という仮説

応募する前に、私は一つの仮説を立てました。

@<b>{「自分の特性的に、イベント駆動学習があっているのではないか？そして、Bookathonはそれをやる最適な機会なのではないか？」}

考えてみれば、私が苦手なのは「継続的な勉強」です。技術書を買っても、最初の数ページを読んで、そのまま積読になってしまう。Udemyの講座を買っても、最初の数本を見て、そのまま放置してしまう。

でも、Bookathonというイベントには、こんな魅力がありました：

 * @<b>{強制的にインプットとアウトプットを行う環境}：2日間という期限がある。やらなきゃいけない状況が作られる
 * @<b>{すごいエンジニアのメンターさんがいる}：学ぶべき技術のアドバイスももらえる。一人じゃない
 * @<b>{楽しく超速レベルアップができるのでは？}：イベントとして楽しみながら学べる。お祭り感がある

継続的な勉強が苦手な私でも、イベントという枠組みの中なら集中できるかもしれない。2日間だけなら、私でも頑張れるかもしれない。

そう思って、私はBookathonに応募することにしました。

=== wakameさんからの超重要アドバイス

イベント初日、私は最初、「5つくらいの技術に触れて、それぞれについて記事を書こう！」と意気込んでいました。

でも、メンターのwakameさんから、私の仮説を大きく変えるアドバイスをいただきました。

==== ① 現実的に2日間で何をどこまでやるか

「5つは多いですね。今回の2日間では、2つくらいがいいと思いますよ。」

え、2つ？5つじゃダメなの？と思いましたが、wakameさんの説明を聞いて納得しました。

 * @<b>{5つではなく、今回の2日間では2つがいい}
 ** 量を追いすぎると浅くなるため。表面をなぞるだけで終わってしまう
 * @<b>{知らない技術ではなく、知っている技術でやった方がいい}
 ** 知らない技術 × 知らないテーマだと、確かに何もわからんで終わるな、と思いました
 * @<b>{テーマ選びに関しても、3割くらい知ってるテーマだと良い}
 ** 全く知らないテーマだと、仮説を持てないため

確かに、5つの技術に触れても、どれも「ふーん、そうなんだ」で終わってしまいそうです。それよりも、2つに絞って、深く学んだ方が、後々役に立つはず。

==== ② 仮説を持って、手を動かすと良い

そして、wakameさんから最も重要なアドバイスがありました。

「『このテーマやります！この技術で手動かします！』ではないんですよ。」

え、違うの？と思いました。だって、Bookathonって、技術書を読んで、手を動かして、記事を書くイベントですよね？

「例えば『失敗をいつ発見するか』というテーマでやる時に、AIが上げてきた技術を鵜呑みにして手を動かし始めるのではなく、@<b>{自分で問いに対して仮説を立てて、それに対して、手を動かして検証するという流れが良い}んです。」

なるほど。ただ手を動かすのではなく、仮説を立ててから手を動かす。

「現状、できる先輩たちは仮説を立てて、それがあってる確率が高いんですよ。でも、あなたはまだそのレベルじゃないですよね？」

痛いところを突かれました。確かに、私は仮説を立てる力がまだまだです。

「だから、@<b>{そもそも仮説を立てることで、スタートラインに立つ}んです。仮説が外れても、それはそれで学びになります。」

==== ③ 失敗したこと、成功したことも含めてログを残す

そして、最後のアドバイス。

「仮説が外れたら『失敗』、仮説があってたら『成功』ですよね。でも、その両方をログに残してください。」

失敗も残すの？と思いましたが、wakameさんの説明を聞いて納得しました。

「@<b>{あとで本を読んだときに、失敗した時のログが残っていると、本の知識と繋がりやすいし、モチベーションにもなる}んですよ。『あ、これBookathonで失敗したやつだ！』って。」

確かに、失敗を隠すのではなく、失敗を記録しておく。そうすることで、後で本を読んだときに、「あの時の失敗は、このことだったのか！」と繋がる瞬間が来るかもしれない。

=== 仮説を持って、手を動かすことにした

wakameさんのアドバイスを受けて、私の方針が固まりました。

 * 今回は、最低1つの仮説を手を動かして検証する
 * 余裕があったら2つ
 * 使う技術はTypeScriptに絞る（仕事でも使っているので、3割くらいは知っている）

最初は5つの技術に触れようと思っていましたが、2つに絞ることにしました。そして、知らない技術ではなく、知っている技術（TypeScript）でやることにしました。

問いに対して仮説を立てて検証する流れ。
仮説を立てることでスタートラインに立つ。
失敗・成功のログを残す意味。

これが、私のBookathonでの学び方になりました。

正直、最初は「仮説を立てる」って何？と思っていました。でも、wakameさんのアドバイスを聞いて、「ああ、これがBookathonの本質なんだな」と気づきました。

ただ手を動かすのではなく、仮説を立ててから手を動かす。そして、失敗も成功もログに残す。

これなら、私でもできるかもしれない。

=== 自分ルール

wakameさんのアドバイスに加えて、私は自分なりのルールを設定しました。

==== ① 仮説を立てる際は、最初からAIに聞かない

最近、私はAIに頼りすぎていると感じていました。分からないことがあると、すぐにChatGPTやClaudeに聞いてしまう。でも、それだと自分で考える力が付かない気がします。

だから、今回は「まずは自分で考えてみて、煮詰まったらAIに聞く」というルールにしました。

なぜこのルールにしたかというと、最初からAIに聞いてしまうと、問いを立てる力や、仮説を立てる力が付かないと思ったからです。

AIは便利です。でも、AIに頼りすぎると、自分で考える機会を失ってしまう。だから、まずは自分で考える。そして、どうしても分からなくなったら、AIに聞く。

==== ② 執筆時、ありのままを書くことを恥ずかしがらない

そして、もう一つのルール。これは、私にとって最も重要なルールでした。

「こんな初歩的なことも知らないことがバレるのは恥ずかしい...」

いつも、私はこう思っていました。記事を書くときも、「こんなこと書いたら、『こんなことも知らないの？』って思われるかな」と不安になります。

でも、今回は、そういう気持ちを全部捨てて、ありのままを書くことにしました。

なぜこのルールにしたかというと、恥ずかしい気持ちをあえて感じることで、これからの勉強への原動力にするためです。

「型エラーがでなければOK」くらいの認識だった自分。「これでミスるかどうかも分からん」と思っている自分。

それを隠さずに書くことで、「ああ、私はこのレベルなんだな」と自覚できます。そして、その自覚が、これから勉強するモチベーションになると思ったんです。

//pagebreak

== 「失敗をいつ発見するか」というテーマに決めた

=== なぜこのテーマなのか

さて、方針が決まったところで、次は「何をテーマにするか」です。

最初、私は全く思いつきませんでした。「書きたいテーマがない...」と思っていました。だから、AIに「技術を横断する軸の案を出してください」と聞いてみました。

AIはいくつかの案を出してくれましたが、その中で私が選んだのは「失敗をいつ発見するか」というテーマでした。

なぜこのテーマを選んだのか？理由は3つあります。

==== ① 自分が少し知ってるテーマだから

wakameさんのアドバイス通り、「3割くらい知ってるテーマ」を選びました。

私は仕事で、新規プロダクトを開発しています。その中で、「あれ、これバグかも」とか「これ、テストした方がいいのかな」とか考えることがあります。つまり、「失敗」について、少しは考えたことがあるんです。

全く知らないテーマだと、仮説を立てることすらできません。でも、少し知っているテーマなら、「こうなんじゃないかな？」という仮説を立てられます。

==== ② プロダクトを提供する一エンジニアとして防止するべき分野だから

そして、このテーマは、私がエンジニアとして成長するために必要な分野だと思いました。

プロダクトを提供する以上、失敗は避けたい。でも、失敗を完全に避けることはできません。だから、「失敗をいつ発見するか」というのは、とても重要なテーマだと思ったんです。

==== ③ 仕事でAIエージェントのテスト設計を行うため

最後の理由は、仕事に直結する理由です。

私は今後、AIエージェントのテスト設計を行う予定があります。でも、正直、テスト設計について、あまり詳しくありません。だから、このBookathonを機に、テスト設計の足掛かりを作りたいと思ったんです。

=== 開発速度が遅いだけで、失敗はしていないのでは？

テーマを決めた時点で、私は自分の現状を振り返りました。

@<b>{「今の私の『失敗』に対する認識」}

新規プロダクトを開発しているけど、まだ私起因のエラーやインシデントは起きていない。確かに開発速度は遅いけど、それは「失敗」ではないよね？失敗というのは、エラーやインシデントが起きることを指すのでは？

そう思っていました。

でも、AIとの壁打ち（対話しながら考えること）をした結果、@<b>{「そんなことはない」}ということに気づきました。

以下の2つの理由によって、私は既に失敗していました。

==== ① 動作確認したら意図した動作と違い手戻りが起きている

開発速度が遅い理由の一つに、実装後に動作確認してみたら意図した動作と違い、手戻りが起きたということが起こっています。

例えば、フロント側の状態管理が複雑になってきた影響で、ローカルで動作確認をしたら、意図した実装になっていなかったことがありました。

「あれ、ボタンを押したのに、画面が更新されない...」

型エラーやビルドエラー、実行時エラーはなかったので、動作確認をして私が確認するまで、わからなかったということになります。

つまり、コードは動くけど、意図した動作にはなっていない。これは「失敗」ですよね。

==== ② 将来の失敗の種を作っている可能性

そして、もっと怖いのは、将来の失敗の種を作っている可能性があることです。

きっと、私が書いたコードは、複雑性を増やしてしまっています。そして、良いテストも書けていない気がします。だから、将来、誰かが（もしくは未来の私が）このコードを触った時に、「なんだこのコード...」となるかもしれません。

さらに、テストが偽陽性になっている可能性もあります。つまり、テストは通っているけど、実際にはバグがある、という状態です。

これも「失敗」ですよね。今はまだ顕在化していないけど、将来顕在化する「失敗の種」を作ってしまっている。

=== 「失敗」を3段階で定義してみた

ここで、私は「失敗」を整理するために、3つのレベルで定義してみました。

==== 失敗レベル1: 将来自分か、他人に2, 3を起こさせてしまうコードを生成すること

これは、今はまだ顕在化していないけど、将来失敗を起こす可能性があるコードを書いてしまうことです。

 * コードの複雑性を増やしてしまう
 * 良いテストが書けていない
 * 将来の自分や他人が理解しづらいコードを書いてしまう

今はまだ問題ないけど、将来問題になる。そういう「失敗の種」を作ってしまうこと。

==== 失敗レベル2: 開発中の手戻りにより開発速度が落ちること

これは、開発中に起きる失敗です。

 * 実装後の動作確認で意図した動作と違うことが発覚
 * 型エラーやビルドエラー、実行時エラーはないけど、動作がおかしい
 * 手戻りが発生して、開発速度が落ちる

私が実際に経験したのは、このレベルの失敗です。「あれ、動かない...」となって、デバッグに時間がかかる。

==== 失敗レベル3: 運用中のエラーによってインシデントが起きること

これは、最も避けたい失敗です。

 * 本番環境でエラーが起きる
 * ユーザーに迷惑をかける
 * インシデント対応に追われる

幸い、私はまだこのレベルの失敗は起こしていません。でも、レベル1やレベル2の失敗を積み重ねると、将来レベル3の失敗が起きる可能性があります。

==== 私が取り組むべきは？

この定義によって、私が今取り組むべきは「レベル2」の失敗を減らすこと、そして「レベル1」の失敗を作らないことだと気づきました。

レベル3の失敗を起こさないためには、レベル2の失敗を減らし、レベル1の失敗を作らないことが重要です。

//pagebreak

== 1つ目の問い「型定義に穴があると、どの時点でエラーが起きるのか？」

=== 今回は型エラーに絞ってみることにした

「失敗をいつ発見するか」というテーマの中で、私はまず、AIによるレビューで発見できる失敗は何か？と考えてみました。

そして、最初に思いついたのが「型エラー」でした。

でも、考え始めると、どんどん疑問が出てきます。

==== 考え始めると、どんどん疑問が出てくる

 * 型エラーって、何を指すんだっけ？
 * てか、型エラーがないと、どの時点でどういうエラーが起きるんだっけ？
 * AIを使うまでもなく、lint checkとかで行けるんか？あと、VSCodeでなんかエラー出るし...
 * でも、テストファイルの型エラーをAIがいつまでも治せなかった覚えがある。あれ、なんでだっけ？

考え始めると、案外知らないこと多い！！！！

==== 当たり前に使っている型というものはなんなのか？

いつも、空気のように感じていた型。

TypeScriptを書いているときに、「型エラーが出た！」となったら、「あ、間違えたんだな」と思って直す。でも、「型って何？」って聞かれたら、ちゃんと答えられない気がします。

それが分からなくても、別に型チェックによって防止してくれるのに、それを深ぼる理由はなんだ？？

そう思っていました。でも、今回はあえて、この「型」というものを深掘りしてみることにしました。

=== やばい、正直、今まで型を蔑ろにしてた

でも、自分で考えても、よく分からない。煮詰まったので、AIに聞いてみました。

「型定義に穴があると、どんな問題が起きるんですか？」

==== → AIに聞いた結果わかったこと

AIの回答は衝撃的でした。

@<b>{「型定義に穴があると、後々エラーとしても出ない不具合が起きます」}

え、エラーとしても出ない不具合？

つまり、型エラーも出ない、ビルドエラーも出ない、実行時エラーも出ない。でも、不具合がある。そういう状態が起きるということです。

やばい、正直、今まで型を蔑ろにしてた。

==== 型エラーがでなければOK、anyはダメくらいの気持ちだった。

私の型に対する認識は、こんな感じでした：

 * 型エラーが出なければ、OK
 * anyを使うのはダメ
 * それ以外は、まあ適当でいいか

でも、AIの回答を聞いて、「あ、やばいな」と思いました。

これまでAIが定義した型にちゃんと目を通してなかった。「AIが書いてくれたから、まあいいか」という感じで、スルーしていました。

し、今もどういう観点で型をチェックすればいいか分からん。

==== 今まで書いてきたコードが不安になってきた。

もしかして、私が書いたコードの中に、「型定義に穴がある」コードがいっぱいあるのでは？

そう思うと、不安になってきました。

=== 問いの設定と実験シチュエーション

不安になったところで、具体的な問いを設定しました。

@<b>{問い：型定義に穴があると、どの時点でエラーが起きるのか？}

この問いに答えるために、具体的なシチュエーションを設定します。

==== 実験のためのシチュエーション定義：ユーザー登録機能

ユーザー登録機能を例にして、型定義を考えてみることにしました。

==== 仮説を出すまでの思考

まず、自分で考えてみます。（ルール①：最初からAIに聞かない）

この機能において、どんな型が考えられる？
（多分AI使わず自分で書けば普通にミスる気がするけど）

まず、ユーザー型：

//emlist[]{
User = {
  id: number,
  name: string,
  email: string,
  password: string
}
//}

うん、これは簡単ですね。ユーザーには、ID、名前、メールアドレス、パスワードがある。

次に、バックエンドに登録内容をポストする関数の型定義：

//emlist[]{
function registerUser(user: User): 成功したかしてないかの返り値の型 {
  // 実装
}
//}

あれ、返り値の型って、どう書けばいいんだ？

==== これでミスるかどうかも分からん

成功したかしてないかの返り値の型というのは、ライブラリ（例えばaxios）でpostした結果のオブジェクトをそのまま入れるものにしようと思ってる。

でも、それって、どういう型なんだろう？@<code>{AxiosResponse}？それとも@<code>{Promise<AxiosResponse>}？

一旦、成功したかしてないかの返り値の型が分からないので、AIに聞いてみることにしました。

==== AIに聞いた結果

AIの回答は、私の予想とは違うものでした。

「Result型を用意した方がいいですよ。」

え、Result型？axiosの返り値をそのまま使うんじゃないの？

AIの説明を聞いて、納得しました。

axiosの返り値をそのまま使うと、以下の問題が起きるそうです：

 * @<b>{ライブラリを変えた時に面倒}
 ** 特定のライブラリ（axios）に依存した型になってしまう
 ** 将来、axiosから別のライブラリに変えたくなった時、呼び出し元も全部変えないといけない
 ** 呼び出し元がライブラリの詳細を知る必要がある
 * @<b>{返り値の中から必要な情報を取り出すのが煩雑になる}
 ** @<code>{response.data}とか@<code>{response.status}とか、axiosの構造を知らないと使えない

なるほど、だからResult型を用意する必要があるのか。

=== 仮説と検証

@<b>{【ここに仮説を記述予定】}

 * 仮説1: ライブラリの返り値をそのまま使うと、呼び出し元でライブラリの詳細を知る必要があり、型定義に穴ができる
 * 仮説2: Result型を定義することで、型安全性が向上し、エラーを早期に発見できる
 * 仮説3: 型定義に穴があると、実行時まで検出されない不具合が起きる

@<b>{【ここに実験コードと結果を記述予定】}

実験1: ライブラリの返り値をそのまま使った場合

//emlist[]{
// 悪い例：ライブラリ依存の型
function registerUser(user: User): Promise<AxiosResponse> {
  return axios.post('/api/users', user);
}

// 呼び出し元
const response = await registerUser(userData);
// response.data? response.status? どう使えばいい？
//}

実験2: Result型を定義した場合

//emlist[]{
// 良い例：Result型で抽象化
type Result<T> =
  | { success: true; data: T }
  | { success: false; error: string };

async function registerUser(user: User): Promise<Result<User>> {
  try {
    const response = await axios.post('/api/users', user);
    return { success: true, data: response.data };
  } catch (error) {
    return { success: false, error: error.message };
  }
}

// 呼び出し元
const result = await registerUser(userData);
if (result.success) {
  // result.dataが型安全に使える
} else {
  // result.errorがある
}
//}

@<b>{【ここに考察を記述予定】}

考察：

 * Result型を使うことで、エラーハンドリングが型レベルで強制される
 * ライブラリの詳細を隠蔽でき、変更に強いコードになる
 * 型定義に穴があると、コンパイル時ではなく実行時にエラーが発覚する

=== 1つ目の問いから学んだこと

==== 今まで書いてきたコードが不安になってきた

型を蔑ろにしていた結果、どれだけの「将来の失敗の種」を作っていたのか。

==== どういう観点で型をチェックすればいいか

 * ライブラリに依存しすぎていないか
 * エラーハンドリングが型レベルで表現されているか
 * 呼び出し元が型安全に使えるか

==== 仮説を立てて手を動かすことで見えたもの

AIに最初から聞いていたら、「Result型を使いましょう」という結論だけで終わっていたかもしれない。
でも、自分で考えて、失敗して、AIに聞いて、実験することで、@<b>{なぜResult型が必要なのか}が腹落ちしました。

//pagebreak

== 2つ目の問い「【2つ目の問いタイトル】」

=== 1つ目の検証から生まれた新たな疑問

@<b>{【1つ目の検証結果を踏まえた問題意識】}

型定義の重要性を理解したところで、新たな疑問が生まれました。

 * Result型を使えば型安全なのはわかった。でも、実際のコードでは複雑な状態管理がある
 * フロント側の状態管理で起きた「意図した動作と違う」問題は、型だけで防げるのか？
 * 型定義が完璧でも、状態の遷移が不正だったら意味がないのでは？

@<b>{【なぜこの問いを立てたのか】}

1つ目の問いで、型定義の重要性を学びました。でも、私が実際に遭遇した「動作確認まで気づかなかった不具合」は、型エラーでは検出されませんでした。

それは、状態管理の問題だったのかもしれない。

=== 問いの設定と実験シチュエーション

@<b>{【2つ目の実験シチュエーション】}

※第4章は、1つ目の検証が終わった後に執筆予定です。間に合わなければ丸ごとカット可能です。

=== 仮説と検証

@<b>{【仮説】}

※執筆予定

@<b>{【実験コードと結果】}

※執筆予定

@<b>{【考察】}

※執筆予定

=== 2つ目の問いから学んだこと

@<b>{【学び】}

※執筆予定

@<b>{【1つ目の問いとの繋がり】}

※執筆予定

//pagebreak

== Bookathonハックで得た学び

=== 仮説駆動で学ぶことの効果

2日間のBookathonが終わろうとしています。振り返ってみて、仮説駆動で学ぶことの効果を実感しています。

==== 問いを立てることでスタートラインに立てた

wakameさんの言葉通り、「仮説を立てることでスタートラインに立つ」という経験をしました。

もし、ただ「型について学ぶ」というテーマだったら、私は何をすればいいか分からなかったと思います。技術書を読んで、「ふーん、そうなんだ」で終わっていたかもしれません。

でも、「型定義に穴があると、どの時点でエラーが起きるのか？」という明確な問いを立てることで、何を実験すればいいかが明確になりました。

「じゃあ、ユーザー登録機能を例にして、型定義を考えてみよう」
「自分で型を書いてみて、どこで間違えるか試してみよう」
「AIに聞いて、自分の考えと何が違うか確認しよう」

問いがあるから、次に何をすればいいかが分かる。これが、仮説駆動学習の力だと感じました。

==== 失敗した時のログが残っていると本の知識と繋がりやすい

そして、wakameさんが言っていた「失敗した時のログが残っていると、本の知識と繋がりやすい」という言葉の意味も、少し分かった気がします。

今回、私は「型エラーがでなければOK」くらいの認識だったことを記録しました。そして、「これでミスるかどうかも分からん」という自分の無知を記録しました。

これから技術書を読むときに、「あ、これBookathonで失敗したやつだ！」と繋がる瞬間が来るはずです。その時に、「ああ、あの時の私はこのレベルだったのか」と実感できると思います。

失敗を隠すのではなく、失敗を記録する。それが、未来の自分への贈り物になる。

=== イベント駆動学習は自分に合っていたのか

さて、最初に立てた仮説に戻ります。

「自分の特性的に、イベント駆動学習があっているのではないか？」

答えは、@<b>{Yes}です。

==== 2日間で何が変わったか

正直に言うと、2日間で全てが変わったわけではありません。私はまだまだ未熟なエンジニアですし、型についても、まだまだ知らないことがたくさんあります。

でも、確実に変わったことがあります。

 * @<b>{型を蔑ろにしていた自分に気づけた}：「型エラーがでなければOK」くらいの認識だったことに気づけた
 * @<b>{仮説を立てて検証する楽しさを知った}：ただ手を動かすのではなく、仮説を立ててから手を動かす楽しさを知った
 * @<b>{ありのままを書くことの大切さを実感した}：恥ずかしいことも含めて書くことで、成長が見える

2日間という短い期間だからこそ、集中できました。継続的な勉強が苦手な私でも、「2日間だけ頑張ろう」と思えました。

そして、2日間という短い期間だからこそ、「このテーマに絞って深掘りしよう」と決断できました。

イベント駆動学習は、私に合っていました。

==== TypeScriptに絞って深掘りした結果

最初は5つの技術に触れようと思っていましたが、wakameさんのアドバイスで2つに絞り、結果的に1つ（TypeScript）に絞って深掘りすることになりました。

5つの技術に浅く触れるのではなく、1つの技術（TypeScript）に絞って深掘りしたことで、腹落ち感が全然違いました。

「ああ、だからResult型が必要なんだ」
「ああ、だからライブラリに依存しない方がいいんだ」

このような「腹落ち」は、浅く広く学んでいたら得られなかったと思います。

wakameさんのアドバイス通り、「量より質」を選んで正解でした。

=== 技術が未熟な新卒エンジニアのための学び方

最後に、私のような技術が未熟な新卒エンジニアのための学び方について、Bookathonで学んだことをまとめます。

==== 完璧な知識がなくても大丈夫

私は、「こんな初歩的なことも知らないのか」とバレるのが怖かったです。

「型って何？」って聞かれたら答えられない。
「Result型って何？」って聞かれても、Bookathon前は知らなかった。

でも、ありのままを書くことで、逆に自分の成長が見えるようになりました。

「ああ、私はこのレベルだったんだな」と自覚することが、成長の第一歩だと思います。

完璧な知識がなくても、Bookathonには参加できます。むしろ、完璧な知識がないからこそ、Bookathonで学ぶ価値があるんです。

==== 恥ずかしがらずにありのままを書く意味

「型エラーがでなければOK」くらいの認識だった自分。
「これでミスるかどうかも分からん」と書いた自分。

これらを隠さず書くことで、これから勉強するモチベーションになります。

そして、未来の自分が読み返した時に、「ああ、あの時の私はこのレベルだったのか。今はこんなに成長したんだな」と実感できるはずです。

恥ずかしいことを書くのは勇気がいります。でも、その勇気が、未来の自分への贈り物になります。

==== 次はどんな問いを立てるか

Bookathonは終わりますが、仮説駆動学習は続けていきます。

今回、私は「型定義に穴があると、どの時点でエラーが起きるのか？」という問いを立てました。そして、その問いに対して、実験しました。

次は、別の問いを立ててみようと思います。

例えば、「状態管理の不具合を早期に発見するには？」という問い。
例えば、「テストの偽陽性を防ぐには？」という問い。

問いを立てて、仮説を立てて、実験する。そのサイクルを回していくことで、私はエンジニアとして成長できると信じています。

//pagebreak

== エピローグ: 書きたいテーマがなくて応募が怖いあなたへ

=== 私も最初は不安だった

この記事を読んでいるあなたは、もしかしたら、第2回Bookathonに応募しようか迷っているかもしれません。

「書きたいテーマがない」
「技術力が足りない」
「他の参加者はすごい人ばかりなのでは」
「2日間で記事を書き上げる自信がない」

私も、同じ不安を抱えていました。

応募する前、私は「書きたいテーマがない」と思っていました。だから、AIに聞いて、テーマを探しました。

応募する前、私は「技術力が足りない」と思っていました。新卒で、基礎もなってない。そんな私がBookathonに参加していいのか、と。

応募する前、私は「他の参加者はすごい人ばかりなのでは」と思っていました。きっと、みんな技術書を何冊も読んでいて、深い知識を持っているんだろうな、と。

でも、参加してみて分かりました。

Bookathonは、@<b>{完璧な知識がなくても、テーマが明確でなくても、参加できるイベント}でした。

むしろ、完璧な知識がないからこそ、Bookathonで学ぶ価値があるんです。

=== Bookathonをフルに使った超加速学習のススメ

もし、あなたが第2回Bookathonに参加するなら、私からのアドバイスがあります。

 * @<b>{メンターさんにアドバイスをもらう}：最初に、メンターさんに相談してみてください。私はwakameさんからのアドバイスで、学び方が大きく変わりました
 * @<b>{仮説を立てて、手を動かす}：ただ手を動かすのではなく、問いを立てて、仮説を立ててから手を動かしてみてください
 * @<b>{失敗も成功もログに残す}：失敗を隠さず、記録してください。それが、未来の自分への贈り物になります
 * @<b>{ありのままを書く}：恥ずかしいことも含めて、ありのままを書いてください。それが、成長の証になります

これだけで、2日間で驚くほど成長できます。

イベント駆動学習の力を、ぜひ体験してみてください。

=== 第2回で会いましょう

この記事を読んで、少しでも「応募してみようかな」と思ってくれたら嬉しいです。

私も、最初は不安でした。でも、参加して本当に良かったと思っています。

第2回Bookathonで、あなたに会えることを楽しみにしています。

一緒に、仮説を立てて、手を動かして、成長しましょう。

//pagebreak

== 対象読者

 * 私のような若手エンジニア
 * 第2回Bookathonに興味があるけど、書きたいテーマがなくて応募が怖い人
 * イベント駆動学習に興味がある人
 * 仮説駆動で学ぶ方法を知りたい人
